import numpy as np
import matplotlib.pyplot as plt
import scipy.integrate as integrate
import scipy.optimize as opt
from numpy.polynomial import Laguerre as lag_poly


quad_arr = np.array([[1, -0.9988664044200710501855,  0.002908622553155140958],
    [2,   -0.994031969432090712585,    0.0067597991957454015028],
    [3,   -0.985354084048005882309,   0.0105905483836509692636],
    [4,   -0.9728643851066920737133,   0.0143808227614855744194],
    [5,   -0.9566109552428079429978,   0.0181155607134893903513],
    [6,   -0.9366566189448779337809,   0.0217802431701247929816],
    [7,   -0.9130785566557918930897,   0.02536067357001239044],
    [8,   -0.8859679795236130486375,   0.0288429935805351980299],
    [9,   -0.8554297694299460846114,   0.0322137282235780166482],
    [10,  -0.821582070859335948356,    0.0354598356151461541607],
    [11,  -0.784555832900399263905,    0.0385687566125876752448],
    [12,  -0.744494302226068538261,    0.041528463090147697422],
    [13,  -0.70155246870682225109,    0.044327504338803275492],
    [14,  -0.6558964656854393607816,   0.0469550513039484329656],
    [15,  -0.6077029271849502391804,   0.0494009384494663149212],
    [16,  -0.5571583045146500543155,   0.0516557030695811384899],
    [17,  -0.5044581449074642016515,   0.0537106218889962465235],
    [18,  -0.449806334974038789147,   0.05555774480621251762357],
    [19,  -0.3934143118975651273942,   0.057189925647728383723],
    [20,  -0.335500245419437356837,    0.058600849813222445835],
    [21,  -0.2762881937795319903276,   0.05978505870426545751],
    [22,  -0.2160072368760417568473,   0.0607379708417702160318],
    [23,  -0.1548905899981459020716,   0.06145589959031666375641],
    [24,  -0.0931747015600861408545,   0.0619360674206832433841],
    [25,  -0.0310983383271888761123,   0.062176616655347262321],
    [26,  0.0310983383271888761123,    0.062176616655347262321],
    [27,  0.09317470156008614085445,   0.0619360674206832433841],
    [28,  0.154890589998145902072,    0.0614558995903166637564],
    [29,  0.2160072368760417568473,    0.0607379708417702160318],
    [30,  0.2762881937795319903276,    0.05978505870426545751],
    [31,  0.335500245419437356837,    0.058600849813222445835],
    [32,  0.3934143118975651273942,    0.057189925647728383723],
    [33,  0.4498063349740387891471,    0.055557744806212517624],
    [34,  0.5044581449074642016515,    0.0537106218889962465235],
    [35,  0.5571583045146500543155,    0.05165570306958113849],
    [36,  0.60770292718495023918,     0.049400938449466314921],
    [37,  0.6558964656854393607816,    0.046955051303948432966],
    [38,  0.7015524687068222510896,    0.044327504338803275492],
    [39,  0.7444943022260685382605,    0.0415284630901476974224],
    [40,  0.7845558329003992639053,    0.0385687566125876752448],
    [41,  0.8215820708593359483563,    0.0354598356151461541607],
    [42,  0.8554297694299460846114,    0.0322137282235780166482],
    [43,  0.8859679795236130486375,    0.02884299358053519803],
    [44,  0.9130785566557918930897,    0.02536067357001239044],
    [45,  0.9366566189448779337809,    0.0217802431701247929816],
    [46,  0.9566109552428079429978,    0.0181155607134893903513],
    [47,  0.9728643851066920737133,    0.0143808227614855744194],
    [48,  0.985354084048005882309,    0.010590548383650969264],
    [49,  0.9940319694320907125851,    0.0067597991957454015028],
    [50,  0.9988664044200710501855,    0.0029086225531551409584]])


ring_j = 0
om_pc = 1  # electron omega_p / omega_c


def integrand(x, om, wave):
    t = 0.5 * np.pi * (1.0 + x)  # affine transform
    beta = 2.0 * np.power(wave * np.cos(0.5 * t), 2)
    return np.sin(t * om) * np.sin(t) * np.exp(-beta) * lag_poly((*np.zeros(ring_j), 1.0))(beta)


def jac_integrand(x, om, wave):
    t = 0.5 * np.pi * (1.0 + x)  # affine transform
    beta = 2.0 * np.power(wave * np.cos(0.5 * t), 2)
    return t * np.cos(t * om) * np.sin(t) * np.exp(-beta) * lag_poly((*np.zeros(ring_j), 1.0))(beta)


def dispersion(om, wave, mass_ratio):
    # electrons
    inner_e = integrand(x=quad_arr[:, 1], om=om, wave=wave)
    quad_e = 0.5 * np.pi * np.tensordot(quad_arr[:, 2], inner_e, axes=([0], [0])) / np.sin(np.pi * om)

    # protons
    alpha_p = -mass_ratio * om
    wave_p = -mass_ratio * wave
    inner_p = integrand(x=quad_arr[:, 1], om=alpha_p, wave=wave_p)
    quad_p = -0.5 * np.pi * np.tensordot(quad_arr[:, 2], inner_p, axes=([0], [0])) / np.sin(np.pi * alpha_p)

    # return dispersion func
    return 1.0 + (om_pc ** 2.0) * (quad_e + mass_ratio * quad_p)


# Main section
mass_ratio = 100
fr = np.linspace(-0.5, 2.5, num=100)
fi = np.linspace(-0.001, 0.3, num=100)
fz = np.tensordot(fr, np.ones_like(fi), axes=0) + 1.0j * np.tensordot(np.ones_like(fr), fi, axes=0)
X, Y = np.meshgrid(fr, fi, indexing='ij')
arr = np.array([[dispersion(om=fz[i, j], wave=0.01, mass_ratio=mass_ratio)
                 for j in range(fz.shape[1])] for i in range(fz.shape[0])])

plt.figure()
plt.contour(X, Y, np.real(arr), 0, colors='g')
plt.contour(X, Y, np.imag(arr), 0, colors='r')
plt.grid(True), plt.show()
